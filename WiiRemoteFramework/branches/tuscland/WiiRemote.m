//
//  WiiRemote.m
//  DarwiinRemote
//
//  Created by KIMURA Hiroaki on 06/12/04.
//  Copyright 2006 KIMURA Hiroaki. All rights reserved.
//

#import "WiiRemote.h"

// define some constants
#define kWiiIRPixelsWidth 1024.0
#define kWiiIRPixelsHeight 768.0

// shall we use another bit of precision for the wiimote?
// note that the calibration is not yet updated to 9 bits of precision
#define USE_ACC_NINTH_LSB_BIT 1


// this type is used a lot (data array):
typedef unsigned char darr[];


typedef UInt16 WiiButtonBitMask;
enum {
	kWiiRemoteTwoButton			= 0x0001,
	kWiiRemoteOneButton			= 0x0002,
	kWiiRemoteBButton			= 0x0004,
	kWiiRemoteAButton			= 0x0008,
	kWiiRemoteMinusButton		= 0x0010,
	kWiiRemoteHomeButton		= 0x0080,
	kWiiRemoteLeftButton		= 0x0100,
	kWiiRemoteRightButton		= 0x0200,
	kWiiRemoteDownButton		= 0x0400,
	kWiiRemoteUpButton			= 0x0800,
	kWiiRemotePlusButton		= 0x1000,
	
	kWiiNunchukZButton			= 0x0001,
	kWiiNunchukCButton			= 0x0002
};


@implementation WiiRemote

- (id) init
{
	self = [super init];

	NSLogDebug (@"Wii instantiated");
	
	if (self != nil) {
		_accX = 0x10;
		_accY = 0x10;
		_accZ = 0x10;
		_buttonData = 0;
		leftPoint = -1;
		_batteryLevel = 0;
		_warningBatteryLevel = 0.05;
		
		_lock = [NSLock new];
		_delegate = nil;
		wiiDevice = nil;
		
		ichan = nil;
		cchan = nil;
		
		isIRSensorEnabled = NO;
		isMotionSensorEnabled = NO;
		isVibrationEnabled = NO;
		isExpansionPortEnabled = NO;
	}
		
	return self;
}

- (void) dealloc
{
	NSLogDebug (@"wii released");
	[self closeConnection];
	[_lock release];
	[super dealloc];
}

- (void) setDelegate:(id) delegate
{
	_delegate = delegate;
}

- (BOOL) available{
	if (wiiDevice != nil)
		return YES;
	
	return NO;
}

- (void)l2capChannelOpenComplete:(IOBluetoothL2CAPChannel*)l2capChannel status:(IOReturn)error
{
	NSLogDebug (@"l2capChannelOpenComplete");
	[_lock unlock];
}

- (void)l2capChannelClosed:(IOBluetoothL2CAPChannel*)l2capChannel
{
	NSLogDebug (@"l2capChannelClosed");

	if (l2capChannel == cchan) {
		cchan = nil;
	} else if (l2capChannel == ichan) {
		ichan = nil;
	}
	
	[_lock unlock];
}

- (IOReturn) connectTo:(IOBluetoothDevice *) device
{	
	wiiDevice = device;
	
	IOReturn ret;
	
	if (wiiDevice == nil)
		return kIOReturnBadArgument;

	NSLogDebug (@"Open device ...");
	if ((ret = [wiiDevice openConnection:nil]) != kIOReturnSuccess) {
		NSLog (@"Could not open connection to the Wii (0x%x)", ret);
		LogIOReturn (ret);
		return ret;
	}

	// need to wait a little bit because for lower values, wii is not always responding fast enough
	// use CFRunLoopRunInMode to wait in order to process sources generated by the Bluetooth Framework
	//
	// ps: if we use lower values than 0.5 s, and if the window is not frontmost, the wii can't connect
	CFRunLoopRunInMode(kCFRunLoopDefaultMode, 1, NO);

/*	if ((ret = [wiiDevice performSDPQuery:nil]) != kIOReturnSuccess) {
		NSLog(@"Could not perform SDP Query (0x%x)...", ret);
		LogIOReturn (ret);
		[wiiDevice closeConnection];
		return ret;
	}

	CFRunLoopRunInMode(kCFRunLoopDefaultMode, 0.01, NO);
*/
	[_lock lock];
	NSLogDebug(@"Open L2CAP 1 ...");
	if ((ret = [wiiDevice openL2CAPChannelAsync:&cchan withPSM:17 delegate:self]) != kIOReturnSuccess) {
		NSLog (@"Could not open L2CAP channel cchan (0x%x)", ret);
		LogIOReturn (ret);
		[self closeConnection];
		return ret;			
	}

	do {
		CFRunLoopRunInMode(kCFRunLoopDefaultMode, 0.01, NO);
	} while (![_lock tryLock]);
	[_lock unlock];
	[cchan retain];

	if (!cchan)
		return kIOReturnNotOpen;
	
	[_lock lock];
	NSLogDebug(@"Open L2CAP 2 ...");
	if ((ret = [wiiDevice openL2CAPChannelAsync:&ichan withPSM:19 delegate:self]) != kIOReturnSuccess) {	// this "19" is magic number ;-)
		NSLog (@"Could not open L2CAP channel ichan (0x%x)", ret);
		LogIOReturn (ret);
		[self closeConnection];
		return ret;
	}
		
	do {
		CFRunLoopRunInMode(kCFRunLoopDefaultMode, 0.01, NO);
	} while (![_lock tryLock]);
	[_lock unlock];
	[ichan retain];

	if (!ichan)
		return kIOReturnNotOpen;
		
	//sensor enable...
	ret = [self setMotionSensorEnabled:NO];
	if (kIOReturnSuccess == ret)
		ret = [self setIRSensorEnabled:NO];
	//stop force feedback
	if (kIOReturnSuccess == ret)
		ret = [self setForceFeedbackEnabled:NO];
	//turn LEDs off
	if (kIOReturnSuccess == ret)
		ret = [self setLEDEnabled1:NO enabled2:NO enabled3:NO enabled4:NO];
	
	if (kIOReturnSuccess != ret) {
		NSLog (@"A problem occured during initialization of the device.");
		LogIOReturn (ret);
		[self closeConnection];
	} else {
//		statusTimer = [[NSTimer scheduledTimerWithTimeInterval:60 target:self selector:@selector(getCurrentStatus:) userInfo:nil repeats:YES] retain];
		[self getCurrentStatus:nil];

		// ????
		int trycount = 0;
		for (trycount = 0; trycount< 10; trycount++){
			[self readData:0x0010 length:16];
			usleep(10000);
		}

		disconnectNotification = [wiiDevice registerForDisconnectNotification:self selector:@selector(disconnected:fromDevice:)];
	}
	
	return ret;
}

- (void)disconnected: (IOBluetoothUserNotification*)note fromDevice: (IOBluetoothDevice*)device {
	
	if ([[device getAddressString] isEqualToString:[self address]]){
		[self closeConnection];
		if (nil != _delegate)
			[_delegate wiiRemoteDisconnected:device];
	}
	
}

- (IOReturn)sendCommand:(const unsigned char*)data length:(size_t)length{
	
	
	unsigned char buf[40];
	memset(buf,0,40);
	buf[0] = 0x52;
	memcpy(buf+1, data, length);
	if (buf[1] == 0x16) length=23;
	else				length++;
	
	int i;
	
	
//	printf ("send%3d:", length);
//	for(i=0 ; i<length ; i++) {
//		printf(" %02X", buf[i]);
//	}
//	printf("\n");
	
	IOReturn ret;
	
	for (i = 0; i < 10; i++){
		ret = [cchan writeSync:buf length:length];
		if (kIOReturnSuccess == ret)
			break;
		usleep(10000);
	}
	
	
	
	return ret;
}


- (double) batteryLevel {
	
	return _batteryLevel;
}

- (NSString*)address{
	return [wiiDevice getAddressString];
}

- (IOReturn)setMotionSensorEnabled:(BOOL)enabled{
	// these variables indicate a desire, and should be updated regardless of the sucess of sending the command
	isMotionSensorEnabled = enabled;
	
	unsigned char cmd[] = {0x12, 0x02, 0x30};
	if (isVibrationEnabled)	cmd[1] |= 0x01;
	if (isMotionSensorEnabled)	cmd[2] |= 0x01;
	if (isIRSensorEnabled)	cmd[2] |= 0x02;
	if (isExpansionPortEnabled && isExpansionPortAttached) cmd[2] = 0x37;
	
	return [self sendCommand:cmd length:3];
}


- (IOReturn)setForceFeedbackEnabled:(BOOL)enabled{
	// these variables indicate a desire, and should be updated regardless of the sucess of sending the command
	isVibrationEnabled = enabled;
	
	unsigned char cmd[] = {0x13, 0x00};
	if (isVibrationEnabled)	cmd[1] |= 0x01;
	if (isIRSensorEnabled)	cmd[1] |= 0x04;
	
	return [self sendCommand:cmd length:2];
}

- (IOReturn)setLEDEnabled1:(BOOL)enabled1 enabled2:(BOOL)enabled2 enabled3:(BOOL)enabled3 enabled4:(BOOL)enabled4{
	unsigned char cmd[] = {0x11, 0x00};
	if (isVibrationEnabled)	cmd[1] |= 0x01;
	if (enabled1)	cmd[1] |= 0x10;
	if (enabled2)	cmd[1] |= 0x20;
	if (enabled3)	cmd[1] |= 0x40;
	if (enabled4)	cmd[1] |= 0x80;
	
	isLED1Illuminated = enabled1;
	isLED2Illuminated = enabled2;
	isLED3Illuminated = enabled3;
	isLED4Illuminated = enabled4;
	
	return 	[self sendCommand:cmd length:2];
}

-(IOReturn)setExpansionPortEnabled:(BOOL)enabled{
	


	isExpansionPortEnabled = enabled;
	if (!isExpansionPortAttached)
		isExpansionPortEnabled = NO;
	
	unsigned char cmd[] = {0x12, 0x02, 0x30};
	if (isVibrationEnabled)	cmd[1] |= 0x01;
	if (isMotionSensorEnabled)	cmd[2] |= 0x01;
	if (isIRSensorEnabled)	cmd[2] |= 0x02;
	if (isExpansionPortEnabled && isExpansionPortAttached) cmd[2] = 0x37;
	
	[self sendCommand:cmd length:3];
	
	IOReturn ret = [self writeData:(darr){0x00} at:(unsigned long)0x04A40040 length:1];
	
	if (ret == kIOReturnSuccess){
		//get calbdata
		[self readData:0x04A40020 length: 16];
	}
	return ret;
}


//based on Ian's codes. thanks!
- (IOReturn)setIRSensorEnabled:(BOOL)enabled{
	IOReturn ret;
	
	isIRSensorEnabled = enabled;

	// set register 0x12 (report type)
	if (ret = [self setMotionSensorEnabled:isMotionSensorEnabled]) return ret;
	
	// set register 0x13 (ir enable/vibe)
	if (ret = [self setForceFeedbackEnabled:isVibrationEnabled]) return ret;
	
	// set register 0x1a (ir enable 2)
	unsigned char cmd[] = {0x1a, 0x00};
	if (enabled)	cmd[1] |= 0x04;
	if (ret = [self sendCommand:cmd length:2]) return ret;
	
	if(enabled){
		// based on marcan's method, found on wiili wiki:
		// tweaked to include some aspects of cliff's setup procedure in the hopes
		// of it actually turning on 100% of the time (was seeing 30-40% failure rate before)
		// the sleeps help it it seems
		usleep(10000);
		if (ret = [self writeData:(darr){0x01} at:0x04B00030 length:1]) return ret;
		usleep(10000);
		if (ret = [self writeData:(darr){0x08} at:0x04B00030 length:1]) return ret;
		usleep(10000);
		if (ret = [self writeData:(darr){0x90} at:0x04B00006 length:1]) return ret;
		usleep(10000);
		if (ret = [self writeData:(darr){0xC0} at:0x04B00008 length:1]) return ret;
		usleep(10000);
		if (ret = [self writeData:(darr){0x40} at:0x04B0001A length:1]) return ret;
		usleep(10000);
		if (ret = [self writeData:(darr){0x33} at:0x04B00033 length:1]) return ret;
		usleep(10000);
		if (ret = [self writeData:(darr){0x08} at:0x04B00030 length:1]) return ret;
		
	}else{
		// probably should do some writes to power down the camera, save battery
		// but don't know how yet.

		[self setMotionSensorEnabled:isMotionSensorEnabled];
		[self setForceFeedbackEnabled:isVibrationEnabled];
		[self setExpansionPortEnabled:isExpansionPortEnabled];
	}
	
	return kIOReturnSuccess;
}


- (IOReturn)writeData:(const unsigned char*)data at:(unsigned long)address length:(size_t)length{
	unsigned char cmd[22];
	//unsigned long addr = CFSwapInt32HostToBig(address);
	unsigned long addr = address;

	int i;
	for(i=0 ; i<length ; i++) {
		cmd[i+6] = data[i];
	}
	for(; i<16; i++) {
		cmd[i+6]= 0;
	}
	cmd[0] = 0x16;
	cmd[1] = (addr>>24)&0xFF;
	cmd[2] = (addr>>16)&0xFF;
	cmd[3] = (addr>> 8)&0xFF;
	cmd[4] = (addr>> 0)&0xFF;
	cmd[5] = length;
	
	// and of course the vibration flag, as usual
	if (isVibrationEnabled)	cmd[1] |= 0x01;
	
	data = cmd;
	
	return [self sendCommand:cmd length:22];
}


- (IOReturn)readData:(unsigned long)address length:(unsigned short)length{
	
	unsigned char cmd[7];
	
	//i'm still not sure whether i don't have to swap these args
	
	//unsigned long addr = CFSwapInt32HostToBig(address);
	unsigned long addr = address;
	//unsigned short len = CFSwapInt16HostToBig(length);
	unsigned short len = length;
	
	cmd[0] = 0x17;
	cmd[1] = (addr>>24)&0xFF;
	cmd[2] = (addr>>16)&0xFF;
	cmd[3] = (addr>> 8)&0xFF;
	cmd[4] = (addr>> 0)&0xFF;
	
	cmd[5] = (len >> 8)&0xFF;
	cmd[6] = (len >> 0)&0xFF;
	
	
	if (isVibrationEnabled)	cmd[1] |= 0x01;
	
	
	return [self sendCommand:cmd length:7];
}


- (IOReturn)closeConnection{
	IOReturn ret = 0;
	int trycount = 0;
	
	if (disconnectNotification!=nil){
		[disconnectNotification unregister];
		disconnectNotification = nil;
	}
	
	
	if (cchan){
		if ([wiiDevice isConnected]) do {
			// cam: set delegate to nil
			[cchan setDelegate:nil];
			ret = [cchan closeChannel];
			trycount++;
		}while(ret != kIOReturnSuccess && trycount < 10);
		[cchan release];
		cchan = nil;
	}

	
	trycount = 0;
	
	if (ichan){
		if ([wiiDevice isConnected]) do {
			// cam: set delegate to nil
			[ichan setDelegate:nil];
			ret = [ichan closeChannel];
			trycount++;
		}while(ret != kIOReturnSuccess && trycount < 10);
		[ichan release];
		ichan = nil;
	}

	
	trycount = 0;

	if (wiiDevice){
		if ([wiiDevice isConnected]) do{
			ret = [wiiDevice closeConnection];
			trycount++;
		}while(ret != kIOReturnSuccess && trycount < 10);
		NSLogDebug (@"closed");
	}
	
	// don't release it, it is owned by the inquiry
	wiiDevice = nil;
	
	// no longer a delegate
	if (statusTimer){
		[statusTimer invalidate];
		[statusTimer release];
		statusTimer = nil;
	}

	
	return ret;
}


// thanks to Ian!
-(void) l2capChannelData:(IOBluetoothL2CAPChannel *) l2capChannel data:(void *) dataPointer length:(size_t) dataLength
{
	if (!wiiDevice)
		return;

	unsigned char * dp = (unsigned char *) dataPointer;

	/**
	if (dp[1] == 0x21){
		int i;
		
		printf ("ack%3d:", dataLength);
		for(i=0 ; i<dataLength ; i++) {
			printf(" %02X", dp[i]);
		}
		printf("\n");
	}**/
	 
	
	// reading ram data
	if (dp[1] == 0x21) {
		//wii calibration data
		if (dataLength >= 20 && dp[5] == 0x00 && dp[6] == 0x10) {
			// cam: updated wii calibration data to reflect the 9th LSB bit addition
#if USE_ACC_NINTH_LSB_BIT			
			wiiCalibData.accX_zero = dp[13] << 1;
			wiiCalibData.accY_zero = dp[14] << 1;
			wiiCalibData.accZ_zero = dp[15] << 1;

			wiiCalibData.accX_1g = dp[17] << 1;
			wiiCalibData.accY_1g = dp[18] << 1;
			wiiCalibData.accZ_1g = dp[19] << 1;
#else
			wiiCalibData.accX_zero = dp[13] << 1;
			wiiCalibData.accY_zero = dp[14] << 1;
			wiiCalibData.accZ_zero = dp[15] << 1;
			
			wiiCalibData.accX_1g = dp[17] << 1;
			wiiCalibData.accY_1g = dp[18] << 1;
			wiiCalibData.accZ_1g = dp[19] << 1;
#endif
		}
				  
		
		//Nunchuk calibration data
		if (dataLength >= 22 && dp[5] == 0x00 && dp[6] == 0x20) {
			nunchukCalibData.accX_zero = (dp[7] ^ 0x17) + 0x17;
			nunchukCalibData.accY_zero = (dp[8] ^ 0x17) + 0x17;
			nunchukCalibData.accZ_zero = (dp[9] ^ 0x17) + 0x17;

			nunchukCalibData.accX_1g = (dp[11] ^ 0x17) + 0x17;
			nunchukCalibData.accY_1g = (dp[12] ^ 0x17) + 0x17;
			nunchukCalibData.accZ_1g = (dp[13] ^ 0x17) + 0x17;

			// cam: corrected Y axis calibration
			nunchukJoyStickCalibData.x_max = (dp[15] ^ 0x17) + 0x17;
			nunchukJoyStickCalibData.x_min = (dp[16] ^ 0x17) + 0x17;
			nunchukJoyStickCalibData.x_center = (dp[17] ^ 0x17) + 0x17;
			nunchukJoyStickCalibData.y_max = (dp[18] ^ 0x17) + 0x17;
			nunchukJoyStickCalibData.y_min = (dp[19] ^ 0x17) + 0x17;
			nunchukJoyStickCalibData.y_center = (dp[20] ^ 0x17) + 0x17;
		} 
	}
	
	
	//controller status (expansion port and battery level data)
	if (dp[1] == 0x20 && dataLength >= 8) {
		// cam: notify the delegate that the battery level has changed
		double level = (double) dp[7];
		level /= (double) 0xC0;
		
		if (level != _batteryLevel) {
			_batteryLevel = level;
			[_delegate batteryLevelChanged:_batteryLevel];
		}

		if (_batteryLevel < _warningBatteryLevel) {
			[[NSNotificationCenter defaultCenter] postNotificationName:@"WiiRemoteBatteryLowNotification" object:self];
		}
		
		if ((dp[4] & 0x02)) {
			if (!isExpansionPortAttached) {
				isExpansionPortAttached = YES;
				[[NSNotificationCenter defaultCenter] postNotificationName:@"WiiRemoteExpansionPortChangedNotification" object:self];
			}
		} else {
			if (isExpansionPortAttached){
				isExpansionPortAttached = NO;
				[self sendWiiNunchukButtonEvent:0xFFFF];		// reset button data;
				[[NSNotificationCenter defaultCenter] postNotificationName:@"WiiRemoteExpansionPortChangedNotification" object:self];
			}
		}
		
		isLED1Illuminated = (dp[4] & 0x10);		
		isLED2Illuminated = (dp[4] & 0x20);
		isLED3Illuminated = (dp[4] & 0x40);
		isLED4Illuminated = (dp[4] & 0x80);		
	}
	
	if ((dp[1] & 0xF0) == 0x30) {
		_buttonData = ((short)dp[2] << 8) + dp[3];
		[self sendWiiRemoteButtonEvent:_buttonData];
		//retrieve nunchuk data
		//if (dp[1] == 0x32 || dp[1] == 0x34 || dp[1] == 0x35 || dp[1] == 0x36 || dp[1] == 0x37 || dp[1] == 0x3D){
		if (dp[1] == 0x37) {
			xStick = (dp[17] ^ 0x17) + 0x17;
			yStick = (dp[18] ^ 0x17) + 0x17;
			nAccX = (dp[19] ^ 0x17) + 0x17;
			nAccY = (dp[20] ^ 0x17) + 0x17;
			nAccZ = (dp[21] ^ 0x17) + 0x17;
			nButtonData = (dp[22] ^ 0x17) + 0x17;
		}

		if (isExpansionPortEnabled && isExpansionPortAttached) {
			[self sendWiiNunchukButtonEvent:nButtonData];
			[_delegate accelerationChanged:WiiNunchukAccelerationSensor accX:nAccX accY:nAccY accZ:nAccZ];
			[_delegate joyStickChanged:WiiNunchukJoyStick tiltX:xStick tiltY:yStick];
		}

		if (dp[1] & 0x01) {
#if USE_ACC_NINTH_LSB_BIT
			// cam: added 9th bit of resolution to the wii acceleration
			// see http://www.wiili.org/index.php/Talk:Wiimote#Remaining_button_state_bits
			//
			_accX = (dp[4] << 1) | (_buttonData & 0x0040) >> 6;
			_accY = (dp[5] << 1) | (_buttonData & 0x2000) >> 13;
			_accZ = (dp[6] << 1) | (_buttonData & 0x4000) >> 14;
#else
			_accX = dp[4];
			_accY = dp[5];
			_accZ = dp[6];
#endif
			[_delegate accelerationChanged:WiiRemoteAccelerationSensor accX:_accX accY:_accY accZ:_accZ];			

			lowZ = lowZ*.9 + _accZ*.1;
			lowX = lowX*.9 + _accX*.1;
			
			double absx = abs(lowX-128), absz = abs(lowZ-128);
			
			if (orientation == 0 || orientation == 2) absx -= 5;
			if (orientation == 1 || orientation == 3) absz -= 5;
			
			if (absz >= absx) {
				if (absz > 5)
					orientation = (lowZ > 128)?0:2;
			} else {
				if (absx > 5)
					orientation = (lowX > 128)?3:1;
			}
		}
		
		if (dp[1] & 0x02) {
			int i;
			for (i=0 ; i<4 ; i++) {
				irData[i].x = dp[7+3*i];
				irData[i].y = dp[8+3*i];
				irData[i].s = dp[9+3*i];
				irData[i].x += (irData[i].s & 0x30)<<4;
				irData[i].y += (irData[i].s & 0xC0)<<2;
				irData[i].s &= 0x0F;
			} 
		}
	}
	
	double ox, oy;
	
	if (irData[0].s < 0x0F && irData[1].s < 0x0F) {
		int l = leftPoint, r;
		if (leftPoint == -1) {
			//	printf("Tracking.\n");
			switch (orientation) {
				case 0: l = (irData[0].x < irData[1].x)?0:1; break;
				case 1: l = (irData[0].y > irData[1].y)?0:1; break;
				case 2: l = (irData[0].x > irData[1].x)?0:1; break;
				case 3: l = (irData[0].y < irData[1].y)?0:1; break;
			}
			leftPoint = l;
		}
		r = 1-l;
		
		double dx = irData[r].x - irData[l].x;
		double dy = irData[r].y - irData[l].y;
		double d = hypot (dx, dy);
		
		dx /= d;
		dy /= d;
		
		double cx = (irData[l].x+irData[r].x)/kWiiIRPixelsWidth - 1;
		
		// cam: change 1024 by 768 in the vertical normalization
		double cy = (irData[l].y+irData[r].y)/kWiiIRPixelsHeight - 1;
		
		ox = -dy*cy-dx*cx;
		oy = -dx*cy+dy*cx;
		
		// cam:
		// Compensate for distance. There must be fewer than 0.75*768 pixels between the spots for this to work.
		// In other words, you have to be far enough away from the sensor bar for the two spots to have enough
		// space on the image sensor to travel without one of
		// the points going off the image.
		// note: it is working very well ...
		double gain = 4;
		if (d < (0.75 * kWiiIRPixelsHeight)) {
			gain = 1 / (1 - d/kWiiIRPixelsHeight);
        }
		
		ox *= gain;
		oy *= gain;		
	} else {
		ox = oy = -100;
		if (leftPoint != -1) {
			//	printf("Not tracking.\n");
			leftPoint = -1;
		}
	}

	if (dp[1] & 0x02)
		[_delegate irPointMovedX:ox Y:oy];
	//if (nil != _delegate)
		//[_delegate dataChanged:_buttonData accX:_accX accY:_accY accZ:_accZ mouseX:ox mouseY:oy];
	//[_delegate dataChanged:_buttonData accX:irData[0].x/4 accY:irData[0].y/3 accZ:irData[0].s*16];
}

- (void)sendWiiRemoteButtonEvent:(UInt16)data{

	if (data & kWiiRemoteTwoButton){
		if (!buttonState[WiiRemoteTwoButton]){
			buttonState[WiiRemoteTwoButton] = YES;
			[_delegate buttonChanged:WiiRemoteTwoButton isPressed:buttonState[WiiRemoteTwoButton]];
		}
	}else{
		if (buttonState[WiiRemoteTwoButton]){
			buttonState[WiiRemoteTwoButton] = NO;
			[_delegate buttonChanged:WiiRemoteTwoButton isPressed:buttonState[WiiRemoteTwoButton]];
		}
	}

	if (data & kWiiRemoteOneButton){
		if (!buttonState[WiiRemoteOneButton]){
			buttonState[WiiRemoteOneButton] = YES;
			[_delegate buttonChanged:WiiRemoteOneButton isPressed:buttonState[WiiRemoteOneButton]];
		}
	}else{
		if (buttonState[WiiRemoteOneButton]){
			buttonState[WiiRemoteOneButton] = NO;
			[_delegate buttonChanged:WiiRemoteOneButton isPressed:buttonState[WiiRemoteOneButton]];
		}
	}
	
	if (data & kWiiRemoteAButton){
		if (!buttonState[WiiRemoteAButton]){
			buttonState[WiiRemoteAButton] = YES;
			[_delegate buttonChanged:WiiRemoteAButton isPressed:buttonState[WiiRemoteAButton]];
		}
	}else{
		if (buttonState[WiiRemoteAButton]){
			buttonState[WiiRemoteAButton] = NO;
			[_delegate buttonChanged:WiiRemoteAButton isPressed:buttonState[WiiRemoteAButton]];
		}
	}
	
	if (data & kWiiRemoteBButton){
		if (!buttonState[WiiRemoteBButton]){
			buttonState[WiiRemoteBButton] = YES;
			[_delegate buttonChanged:WiiRemoteBButton isPressed:buttonState[WiiRemoteBButton]];
		}
	}else{
		if (buttonState[WiiRemoteBButton]){
			buttonState[WiiRemoteBButton] = NO;
			[_delegate buttonChanged:WiiRemoteBButton isPressed:buttonState[WiiRemoteBButton]];
		}
	}
	
	if (data & kWiiRemoteMinusButton){
		if (!buttonState[WiiRemoteMinusButton]){
			buttonState[WiiRemoteMinusButton] = YES;
			[_delegate buttonChanged:WiiRemoteMinusButton isPressed:buttonState[WiiRemoteMinusButton]];
		}
	}else{
		if (buttonState[WiiRemoteMinusButton]){
			buttonState[WiiRemoteMinusButton] = NO;
			[_delegate buttonChanged:WiiRemoteMinusButton isPressed:buttonState[WiiRemoteMinusButton]];
		}
	}
	
	if (data & kWiiRemoteHomeButton){
		if (!buttonState[WiiRemoteHomeButton]){
			buttonState[WiiRemoteHomeButton] = YES;
			[_delegate buttonChanged:WiiRemoteHomeButton isPressed:buttonState[WiiRemoteHomeButton]];
		}
	}else{
		if (buttonState[WiiRemoteHomeButton]){
			buttonState[WiiRemoteHomeButton] = NO;
			[_delegate buttonChanged:WiiRemoteHomeButton isPressed:buttonState[WiiRemoteHomeButton]];
		}
	}
	
	if (data & kWiiRemotePlusButton){
		if (!buttonState[WiiRemotePlusButton]){
			buttonState[WiiRemotePlusButton] = YES;
			[_delegate buttonChanged:WiiRemotePlusButton isPressed:buttonState[WiiRemotePlusButton]];
		}
	}else{
		if (buttonState[WiiRemotePlusButton]){
			buttonState[WiiRemotePlusButton] = NO;
			[_delegate buttonChanged:WiiRemotePlusButton isPressed:buttonState[WiiRemotePlusButton]];
		}
	}
	
	if (data & kWiiRemoteUpButton){
		if (!buttonState[WiiRemoteUpButton]){
			buttonState[WiiRemoteUpButton] = YES;
			[_delegate buttonChanged:WiiRemoteUpButton isPressed:buttonState[WiiRemoteUpButton]];
		}
	}else{
		if (buttonState[WiiRemoteUpButton]){
			buttonState[WiiRemoteUpButton] = NO;
			[_delegate buttonChanged:WiiRemoteUpButton isPressed:buttonState[WiiRemoteUpButton]];
		}
	}
	
	if (data & kWiiRemoteDownButton){
		if (!buttonState[WiiRemoteDownButton]){
			buttonState[WiiRemoteDownButton] = YES;
			[_delegate buttonChanged:WiiRemoteDownButton isPressed:buttonState[WiiRemoteDownButton]];
		}
	}else{
		if (buttonState[WiiRemoteDownButton]){
			buttonState[WiiRemoteDownButton] = NO;
			[_delegate buttonChanged:WiiRemoteDownButton isPressed:buttonState[WiiRemoteDownButton]];
		}
	}

	if (data & kWiiRemoteLeftButton){
		if (!buttonState[WiiRemoteLeftButton]){
			buttonState[WiiRemoteLeftButton] = YES;
			[_delegate buttonChanged:WiiRemoteLeftButton isPressed:buttonState[WiiRemoteLeftButton]];
		}
	}else{
		if (buttonState[WiiRemoteLeftButton]){
			buttonState[WiiRemoteLeftButton] = NO;
			[_delegate buttonChanged:WiiRemoteLeftButton isPressed:buttonState[WiiRemoteLeftButton]];
		}
	}
	
	
	if (data & kWiiRemoteRightButton){
		if (!buttonState[WiiRemoteRightButton]){
			buttonState[WiiRemoteRightButton] = YES;
			[_delegate buttonChanged:WiiRemoteRightButton isPressed:buttonState[WiiRemoteRightButton]];
		}
	}else{
		if (buttonState[WiiRemoteRightButton]){
			buttonState[WiiRemoteRightButton] = NO;
			[_delegate buttonChanged:WiiRemoteRightButton isPressed:buttonState[WiiRemoteRightButton]];
		}
	}
}

- (void)sendWiiNunchukButtonEvent:(UInt16)data{
	if (!(data & kWiiNunchukCButton)){
		if (!buttonState[WiiNunchukCButton]){
			buttonState[WiiNunchukCButton] = YES;
			[_delegate buttonChanged:WiiNunchukCButton isPressed:buttonState[WiiNunchukCButton]];
		}
	}else{
		if (buttonState[WiiNunchukCButton]){
			buttonState[WiiNunchukCButton] = NO;
			[_delegate buttonChanged:WiiNunchukCButton isPressed:buttonState[WiiNunchukCButton]];
		}
	}
	
	if (!(data & kWiiNunchukZButton)){

		if (!buttonState[WiiNunchukZButton]){
			buttonState[WiiNunchukZButton] = YES;
			[_delegate buttonChanged:WiiNunchukZButton isPressed:buttonState[WiiNunchukZButton]];
		}
	}else{
		if (buttonState[WiiNunchukZButton]){
			buttonState[WiiNunchukZButton] = NO;
			[_delegate buttonChanged:WiiNunchukZButton isPressed:buttonState[WiiNunchukZButton]];
		}
	}
}


- (void)getCurrentStatus:(NSTimer*)timer{
	unsigned char cmd[] = {0x15, 0x00};
	[self sendCommand:cmd length:2];
}

- (BOOL)isExpansionPortAttached{
	return isExpansionPortAttached;
}

- (BOOL)isButtonPressed:(WiiButtonType)type{
	return buttonState[type];
}

- (WiiJoyStickCalibData)joyStickCalibData:(WiiJoyStickType)type{
	WiiJoyStickCalibData data;
	
	switch(type){
		case WiiNunchukJoyStick:
			return nunchukJoyStickCalibData;
		default:
			return data;
	}
}
- (WiiAccCalibData)accCalibData:(WiiAccelerationSensorType)type{
	WiiAccCalibData data;
	
	switch(type){
		case WiiRemoteAccelerationSensor:
			return wiiCalibData;
		case WiiNunchukAccelerationSensor:
			return nunchukCalibData;
		default:
			return data;
	}
}

@end
